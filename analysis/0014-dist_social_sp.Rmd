---
title: "Visualização geográfica por distância social (PIB) no estado de São Paulo"
author: "Rafael Vinicius Curiel"
date: "01/02/2022"
output: html_document
---

## Pacotes e comandos

Carregamento dos pacotes  
```{r message=FALSE, warning=FALSE}
pacotes <- c("tidyverse","rgdal","spdep","knitr","kableExtra","tmap","gtools")
sapply(pacotes, require, character = T) 
```


## Carregamento do objeto

Carregamento da base de dados
```{r message=FALSE, warning=FALSE}
base::load("D:\\datasets\\dados_sp.RData")
shp_sp <- rgdal::readOGR(dsn = "D:\\datasets\\shapefile_sp", layer = "estado_sp")
```



### Manipulação

União das bases:
```{r}
shp_sp@data %>% 
  dplyr::rename(codigo = 2) %>% 
  dplyr::mutate(codigo = as.numeric(codigo)) %>% 
  dplyr::left_join(dados_sp, by = "codigo") -> shp_sp@data
```


Visualização da união:
```{r}
utils::head(shp_sp@data)
```


Distância de corte di(k) - Cut-off com variação de  0.01 desvio-padrão:
```{r}
shp_sp@data["Zpib"] <- raster::scale(shp_sp@data$pib)
```


Visualização estatística:
```{r}
base::summary(shp_sp@data)
base::mean(shp_sp@data$Zpib)
```


Função de distanciamento social:
```{r}
distancia_social <- function(x, dmin, dmax, style){
  vessel.list <- base::list()
  x <- base::data.frame(x = x)
  for(i in 1:base::nrow(x)){
    y <- x$x[i]
    x %>% 
      dplyr::mutate(index = ifelse(x >= y & x <= y + dmax,
                                   yes = 1,
                                   no = 0)) %>% 
      dplyr::select(index) -> vector
    vector <- base::as.vector(base::unlist(vector))
    vector[[i]] <- 0
    vessel.list[[i]] <- vector
    }
  data <- base::matrix(base::unlist(vessel.list), ncol = base::nrow(x), byrow = T)
  if(style == "W"){
    wdata <- data * 1/base::rowSums(data)
    wdata[base::is.nan(wdata)] <- 0
    return(wdata)} 
  else if(style == "C"){
    sum.vector <- base::rowSums(data) == 0
    sum.verifier <- base::as.numeric(sum.vector)
    no.links <- base::sum(sum.verifier)
    links <- base::NROW(data) - no.links
    weightsC <- links / base::sum(data)
    vectorC <- base::gsub(1, weightsC, data)
    cdata <- base::matrix(vectorC, ncol = base::NCOL(data), nrow = base::NROW(data))
    return(cdata)} 
  else if(style == "U"){
    sum.vector <- base::rowSums(data) == 0
    sum.verifier <- base::as.numeric(sum.vector)
    no.links <- base::sum(sum.verifier)
    links <- base::NROW(data) - no.links
    weightsC <- links / base::sum(data)
    weightsU <- weightsC / links
    vectorU <- base::gsub(1, weightsU, data)
    udata <- base::matrix(vectorU, ncol = base::NCOL(data), nrow = base::NROW(data))
    return(udata)}
  else if(style == "S"){
    step1 <- base::sqrt(base::rowSums(data^2))
    res.step1 <- data / step1
    res.step1[base::is.nan(res.step1)] <- 0
    step2 <- base::sum(res.step1)
    sum.vector <- base::rowSums(data) == 0
    sum.verifier <- base::as.numeric(sum.vector)
    no.links <- base::sum(sum.verifier)
    links <- base::NROW(data) - no.links
    step3 <- links / step2
    sdata <- res.step1 * step3
    return(sdata)
  }
  else if(style == "B"){return(data)}
  else {break()}
}
```


Criação de matriz W:
```{r}
matrizW_distsocial <- distancia_social(x = shp_sp@data$Zpib, 
                                       dmin = 0, 
                                       dmax = 0.01, 
                                       style = "B")

colnames(matrizW_distsocial) <- shp_sp@data$NM_MUNICIP
rownames(matrizW_distsocial) <- shp_sp@data$NM_MUNICIP
```


Vizinhança por Distância Social:
```{r}
nb_distsocial <- spdep::mat2listw(x = matrizW_distsocial)
```


### Visualização

Visualização por Distância Social:
```{r}
raster::plot(shp_sp, border = "lightgray", main = "Vizinhança por Distância Social")

raster::plot(nb_distsocial, coordinates(shp_sp), add = TRUE, col = "#FDE725FF")
```

